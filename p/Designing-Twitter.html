<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="SystemDesign,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.0">






<meta name="description" content="What is Twitter?Twitter is an online social networking service where users post and read short 140-character messages called “tweets”. Registered users can post and read tweets, but those who are not">
<meta name="keywords" content="SystemDesign">
<meta property="og:type" content="article">
<meta property="og:title" content="Designing Twitter">
<meta property="og:url" content="https://wangleileichina.github.io/p/Designing-Twitter.html">
<meta property="og:site_name" content="PREPARES">
<meta property="og:description" content="What is Twitter?Twitter is an online social networking service where users post and read short 140-character messages called “tweets”. Registered users can post and read tweets, but those who are not">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/40.png">
<meta property="og:image" content="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/41.png">
<meta property="og:image" content="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/42.png">
<meta property="og:image" content="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/43.png">
<meta property="og:updated_time" content="2021-08-23T13:43:13.708Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Designing Twitter">
<meta name="twitter:description" content="What is Twitter?Twitter is an online social networking service where users post and read short 140-character messages called “tweets”. Registered users can post and read tweets, but those who are not">
<meta name="twitter:image" content="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/40.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wangleileichina.github.io/p/Designing-Twitter.html">





  <title> Designing Twitter | PREPARES </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PREPARES</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://wangleileichina.github.io/p/Designing-Twitter.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LeileiWang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PREPARES">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Designing Twitter
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-08-23T21:38:25+08:00">
                2021-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="What-is-Twitter"><a href="#What-is-Twitter" class="headerlink" title="What is Twitter?"></a>What is Twitter?</h2><p>Twitter is an online social networking service where users post and read short 140-character messages called “tweets”. Registered users can post and read tweets, but those who are not registered can only read them. Users access Twitter through their website interface, SMS, or mobile app.</p>
<h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>We will be designing a simpler version of Twitter with the following requirements:<br><strong>Functional Requirements</strong>:</p>
<ol>
<li>Users should be able to post new tweets;</li>
<li>A user should be able to follow other users;</li>
<li>Users should be able to mark tweets as favorites;</li>
<li>The service should be able to create and display a user’s timeline consisting of top tweets from all the people the user follows;</li>
<li>Tweets can contain photos and videos;</li>
</ol>
<p><strong>Non-Functional Requirements</strong>:</p>
<ol>
<li>Our service needs to be highly available;</li>
<li>Acceptable latency of the system is 200ms for timeline generation;</li>
<li>Consistency can take a hit (in the interest of availability); if a user doesn’t see a tweet for a while, it should be fine;</li>
</ol>
<p><strong>Extended Requirements</strong>:</p>
<ol>
<li>Searching for tweets;</li>
<li>Replying to a tweet;</li>
<li>Trending topics – current hot topics/searches;</li>
<li>Tagging other users;</li>
<li>Tweet Notification;</li>
<li>Who to follow? Suggestions?</li>
<li>Moments;</li>
</ol>
<a id="more"></a>
<h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Let’s assume we have one billion total users with 200 million Daily Active Users (DAU). Also assume we have 100 million new tweets every day and on average each user follows 200 people.</p>
<p><strong>How many favorites per day</strong>? If, on average, each user favorites five tweets per day we will have:</p>
<blockquote>
<p>200M users * 5 favorites = 1B favorites</p>
</blockquote>
<p><strong>How many total tweet-views will our system generate</strong>? Let’s assume on average a user visits their timeline two times a day and visits five other people’s pages. On each page if a user sees 20 tweets, then our system will generate 28B/day total tweet-views:</p>
<blockquote>
<p>200M DAU * ((2 + 5) * 20 tweets) = 28 B/day</p>
</blockquote>
<p><strong>Storage estimates</strong>: Let’s say each tweet has 140 characters and we need two bytes to store a character without compression. Let’s assume we need 30 bytes to store metadata with each tweet (like ID, timestamp, user ID, etc.). Total storage we would need:</p>
<blockquote>
<p>100M * (280 + 30) bytes ≈ 30 GB/day</p>
</blockquote>
<p>What would our storage needs be for five years? How much storage we would need for users’ data, follows, favorites? We will leave this for the exercise.<br>Not all tweets will have media, let’s assume that on average every fifth tweet has a photo and every tenth has a video. Let’s also assume on average a photo is 200KB and a video is 2MB. This will lead us to have 24TB of new media every day:</p>
<blockquote>
<p>(100M/5 photos * 200KB) + (100M/10 videos * 2MB) ≈ 24 TB/day</p>
</blockquote>
<p><strong>Bandwidth estimates</strong>: Since total ingress is 24TB per day, this would translate into 290MB/sec. Remember that we have 28B tweet views per day. We must show the photo of every tweet (if it has a photo), but let’s assume that the users watch every 3rd video they see in their timeline. So, total egress will be:</p>
<blockquote>
<p>(28B * 280 bytes) / 86400s of text + (28B/5 * 200KB ) / 86400s of photos + (28B/10/3 * 2MB ) / 86400s of videos ≈ 35 GB/s</p>
</blockquote>
<h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><blockquote>
<p>Once we’ve finalized the requirements, it’s always a good idea to define the system APIs. This should explicitly state what is expected from the system.</p>
</blockquote>
<p>We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definition of the API for posting a new tweet:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweet(api_dev_key, tweet_data, tweet_location, user_location, media_ids)</span><br></pre></td></tr></table></figure>

<p><strong>Parameters</strong>:</p>
<ul>
<li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li>
<li>tweet_data: The text of the tweet, typically up to 140 characters;</li>
<li>tweet_location: Optional location (longitude, latitude) this Tweet refers to;</li>
<li>user_location: Optional location (longitude, latitude) of the user adding the tweet;</li>
<li>media_ids: Optional list of media_ids to be associated with the Tweet. (all the media photo, video, etc. need to be uploaded separately);</li>
</ul>
<p><strong>Returns</strong>: A successful post will return the URL to access that tweet. Otherwise, an appropriate HTTP error is returned.</p>
<h2 id="High-Level-System-Design"><a href="#High-Level-System-Design" class="headerlink" title="High-Level System Design"></a>High-Level System Design</h2><p>We need a system that can efficiently store all the new tweets, “100M/86400s ≈ 1150” tweets per second and read “28B/86400s ≈ 325K” tweets per second. It is clear from the requirements that this will be a read-heavy system.<br>At a high level, we need multiple application servers to serve all these requests with load balancers in front of them for traffic distributions. On the backend, we need an efficient database that can store all the new tweets and can support a huge number of reads. We also need some file storage to store photos and videos:<br><img src="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/40.png" alt></p>
<p>Although our expected daily write load is 100 million and read load is 28 billion tweets. This means on average our system will receive around 1160 new tweets and 325K read requests per second. This traffic will be distributed unevenly throughout the day, though, at peak time we should expect at least a few thousand write requests and around 1M read requests per second. We should keep this in mind while designing the architecture of our system.</p>
<h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p>We need to store data about users, their tweets, their favorite tweets, and people they follow:<br><img src="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/41.png" alt></p>
<p>For choosing between SQL and NoSQL databases to store the above schema, please see “Database Schema” under Designing Instagram.</p>
<h2 id="Data-Sharding"><a href="#Data-Sharding" class="headerlink" title="Data Sharding"></a>Data Sharding</h2><p>Since we have a huge number of new tweets every day and our read load is extremely high too, we need to distribute our data onto multiple machines such that we can read/write it efficiently. We have many options to shard our data; let’s go through them one by one.</p>
<p><strong>Sharding based on UserID</strong>: We can try storing all the data of a user on one server. While storing, we can pass the UserID to our hash function that will map the user to a database server where we will store all of the user’s tweets, favorites, follows, etc. While querying for tweets/follows/favorites of a user, we can ask our hash function where can we find the data of a user and then read it from there. This approach has a couple of issues:</p>
<ol>
<li>What if a user becomes hot? There could be a lot of queries on the server holding the user. This high load will affect the performance of our service;</li>
<li>Over time some users can end up storing a lot of tweets or having a lot of follows compared to others. Maintaining a uniform distribution of growing user data is quite difficult;</li>
</ol>
<p>To recover from these situations either we have to repartition/redistribute our data or use consistent hashing.</p>
<p><strong>Sharding based on TweetID</strong>: Our hash function will map each TweetID to a random server where we will store that Tweet. To search for tweets, we have to query all servers, and each server will return a set of tweets. A centralized server will aggregate these results to return them to the user. Let’s look into timeline generation example; here are the number of steps our system has to perform to generate a user’s timeline:</p>
<ol>
<li>Our application (app) server will find all the people the user follows;</li>
<li>App server will send the query to all database servers to find tweets from these people;</li>
<li>Each database server will find the tweets for each user, sort them by recency and return the top tweets;</li>
<li>App server will merge all the results and sort them again to return the top results to the user;</li>
</ol>
<p>This approach solves the problem of hot users, but, in contrast to sharding by UserID, we have to query all database partitions to find tweets of a user, which can result in higher latencies.<br>We can further improve our performance by introducing cache to store hot tweets in front of the database servers.</p>
<p><strong>Sharding based on Tweet creation time</strong>: Storing tweets based on creation time will give us the advantage of fetching all the top tweets quickly and we only have to query a very small set of servers. The problem here is that the traffic load will not be distributed, e.g., while writing, all new tweets will be going to one server and the remaining servers will be sitting idle. Similarly, while reading, the server holding the latest data will have a very high load as compared to servers holding old data.</p>
<p><strong>What if we can combine sharding by TweetID and Tweet creation time</strong>? If we don’t store tweet creation time separately and use TweetID to reflect that, we can get benefits of both the approaches. This way it will be quite quick to find the latest Tweets. For this, we must make each TweetID universally unique in our system and each TweetID should contain a timestamp too.<br>We can use epoch time for this. Let’s say our TweetID will have two parts: the first part will be representing epoch seconds and the second part will be an auto-incrementing sequence. So, to make a new TweetID, we can take the current epoch time and append an auto-incrementing number to it. We can figure out the shard number from this TweetID and store it there:<br><img src="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/42.png" alt></p>
<p>What could be the size of our TweetID? Let’s say our epoch time starts today, how many bits we would need to store the number of seconds for the next 50 years:</p>
<blockquote>
<p>86400 sec/day * 365 (days a year) * 50 (years) ≈ 1.6 B</p>
</blockquote>
<p>We would need 31 bits to store this number. Since on average we are expecting 1150 new tweets per second, we can allocate 17 bits to store auto incremented sequence; this will make our TweetID 48 bits long. So, every second we can store (2^17 ≈ 130K) new tweets. We can reset our auto incrementing sequence every second. For fault tolerance and better performance, we can have two database servers to generate auto-incrementing keys for us, one generating even numbered keys and the other generating odd numbered keys.<br>If we assume our current epoch seconds are “1483228800”, our TweetID will look like this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1483228800</span> <span class="number">000001</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000002</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000003</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000004</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>If we make our TweetID 64bits (8 bytes) long, we can easily store tweets for the next 100 years and also store them for milliseconds granularity.<br>In the above approach, we still have to query all the servers for timeline generation, but our reads (and writes) will be substantially quicker:</p>
<ol>
<li>Since we don’t have any secondary index (on creation time) this will reduce our write latency;</li>
<li>While reading, we don’t need to filter on creation-time as our primary key has epoch time included in it;</li>
</ol>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>We can introduce a cache for database servers to cache hot tweets and users. We can use an off-the-shelf solution like Memcache that can store the whole tweet objects. Application servers, before hitting database, can quickly check if the cache has desired tweets. Based on clients’ usage patterns we can determine how many cache servers we need.</p>
<p><strong>Which cache replacement policy would best fit our needs</strong>? When the cache is full and we want to replace a tweet with a newer/hotter tweet, how would we choose? Least Recently Used (LRU) can be a reasonable policy for our system. Under this policy, we discard the least recently viewed tweet first.</p>
<p><strong>How can we have a more intelligent cache</strong>? If we go with 80-20 rule, that is 20% of tweets generating 80% of read traffic which means that certain tweets are so popular that a majority of people read them. This dictates that we can try to cache 20% of daily read volume from each shard.</p>
<p><strong>What if we cache the latest data</strong>? Our service can benefit from this approach. Let’s say if 80% of our users see tweets from the past three days only; we can try to cache all the tweets from the past three days. Let’s say we have dedicated cache servers that cache all the tweets from all the users from the past three days. As estimated above, we are getting 100 million new tweets or 30GB of new data every day (without photos and videos). If we want to store all the tweets from last three days, we will need less than 100GB of memory. This data can easily fit into one server, but we should replicate it onto multiple servers to distribute all the read traffic to reduce the load on cache servers. So whenever we are generating a user’s timeline, we can ask the cache servers if they have all the recent tweets for that user. If yes, we can simply return all the data from the cache. If we don’t have enough tweets in the cache, we have to query the backend server to fetch that data. On a similar design, we can try caching photos and videos from the last three days.<br>Our cache would be like a hash table where “key” would be “OwnerID” and “value” would be a doubly linked list containing all the tweets from that user in the past three days. Since we want to retrieve the most recent data first, we can always insert new tweets at the head of the linked list, which means all the older tweets will be near the tail of the linked list. Therefore, we can remove tweets from the tail to make space for newer tweets:<br><img src="https://github.com/wangleileichina/HexoPosts/raw/master/SystemDesign/Designing-Twitter/43.png" alt></p>
<h2 id="Timeline-Generation"><a href="#Timeline-Generation" class="headerlink" title="Timeline Generation"></a>Timeline Generation</h2><p>For a detailed discussion about timeline generation, take a look at <a href>Designing Facebook’s News Feed</a>.</p>
<h2 id="Replication-and-Fault-Tolerance"><a href="#Replication-and-Fault-Tolerance" class="headerlink" title="Replication and Fault Tolerance"></a>Replication and Fault Tolerance</h2><p>Since our system is read-heavy, we can have multiple secondary database servers for each DB partition. Secondary servers will be used for read traffic only. All writes will first go to the primary server and then will be replicated to secondary servers. This scheme will also give us fault tolerance, since whenever the primary server goes down we can failover to a secondary server.</p>
<h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We can add load balancing layer at three places in our system:</p>
<ol>
<li>Between Clients and Application Servers;</li>
<li>Between Application Servers and Database Replication Servers;</li>
<li>Between Aggregation Servers and Cache Servers;</li>
</ol>
<p>Initially, a simple Round Robin approach can be adopted; that distributes incoming requests equally among servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is that if a server is dead, LB will take it out of the rotation and will stop sending any traffic to it. A problem with Round Robin LB is that it won’t take servers load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to that server. To handle this, a more intelligent LB solution can be placed that periodically queries backend server about their load and adjusts traffic based on that.</p>
<h2 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h2><p>Having the ability to monitor our systems is crucial. We should constantly collect data to get an instant insight into how our system is doing. We can collect following metrics/counters to get an understanding of the performance of our service:</p>
<ol>
<li>New tweets per day/second, what is the daily peak?</li>
<li>Timeline delivery stats, how many tweets per day/second our service is delivering;</li>
<li>Average latency that is seen by the user to refresh timeline;</li>
</ol>
<p>By monitoring these counters, we will realize if we need more replication, load balancing, or caching.</p>
<h2 id="Extended-Requirements"><a href="#Extended-Requirements" class="headerlink" title="Extended Requirements"></a>Extended Requirements</h2><p><strong>How do we serve feeds</strong>? Get all the latest tweets from the people someone follows and merge/sort them by time. Use pagination to fetch/show tweets. Only fetch top N tweets from all the people someone follows. This N will depend on the client’s viewport, since on a mobile we show fewer tweets compared to a Web client. We can also cache next top tweets to speed things up.</p>
<p><strong>Alternately</strong>, we can pre-generate the feed to improve efficiency; for details please see “Ranking and News Feed Generation” under Designing Instagram.</p>
<p><strong>Retweet</strong>: With each Tweet object in the database, we can store the ID of the original Tweet and not store any contents on this retweet object.</p>
<p><strong>Trending Topics</strong>: We can cache most frequently occurring hashtags or search queries in the last N seconds and keep updating them after every M seconds. We can rank trending topics based on the frequency of tweets or search queries or retweets or likes. We can give more weight to topics which are shown to more people.</p>
<p><strong>Who to follow? How to give suggestions</strong>? This feature will improve user engagement. We can suggest friends of people someone follows. We can go two or three levels down to find famous people for the suggestions. We can give preference to people with more followers.<br>As only a few suggestions can be made at any time, use Machine Learning to shuffle and re-prioritize. ML signals could include people with recently increased follow-ship, common followers if the other person is following this user, common location or interests, etc.</p>
<p><strong>Moments</strong>: Get top news for different websites for past 1 or 2 hours, figure out related tweets, prioritize them, categorize them (news, support, financial, entertainment, etc.) using ML - Supervised Learning or Clustering. Then we can show these articles as trending topics in Moments.</p>
<p><strong>Search</strong>: Search involves Indexing, Ranking, and Retrieval of tweets. A similar solution is discussed in Design Twitter Search.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SystemDesign/" rel="tag"># SystemDesign</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/p/Designing-Facebook-Messenger.html" rel="next" title="Designing Facebook Messenger">
                <i class="fa fa-chevron-left"></i> Designing Facebook Messenger
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="LeileiWang">
          <p class="site-author-name" itemprop="name">LeileiWang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wangleileichina" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href target="_blank" title="LinkedIn">
                  
                  LinkedIn
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Twitter"><span class="nav-number">1.</span> <span class="nav-text">What is Twitter?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Requirements-and-Goals-of-the-System"><span class="nav-number">2.</span> <span class="nav-text">Requirements and Goals of the System</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Capacity-Estimation-and-Constraints"><span class="nav-number">3.</span> <span class="nav-text">Capacity Estimation and Constraints</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#System-APIs"><span class="nav-number">4.</span> <span class="nav-text">System APIs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#High-Level-System-Design"><span class="nav-number">5.</span> <span class="nav-text">High-Level System Design</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Database-Schema"><span class="nav-number">6.</span> <span class="nav-text">Database Schema</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-Sharding"><span class="nav-number">7.</span> <span class="nav-text">Data Sharding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache"><span class="nav-number">8.</span> <span class="nav-text">Cache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Timeline-Generation"><span class="nav-number">9.</span> <span class="nav-text">Timeline Generation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Replication-and-Fault-Tolerance"><span class="nav-number">10.</span> <span class="nav-text">Replication and Fault Tolerance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Load-Balancing"><span class="nav-number">11.</span> <span class="nav-text">Load Balancing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monitoring"><span class="nav-number">12.</span> <span class="nav-text">Monitoring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Extended-Requirements"><span class="nav-number">13.</span> <span class="nav-text">Extended Requirements</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeileiWang</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="local-search-pop-overlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  

  

  

  


  

</body>
</html>
